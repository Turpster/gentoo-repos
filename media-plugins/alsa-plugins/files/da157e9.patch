From 2352e4e8df7a31cb8a446ca0a32cdb8c5a56a017 Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Fri, 11 Jun 2021 21:09:03 +0200
Subject: [PATCH 01/29] jack: trace the running state

Fixes: https://github.com/alsa-project/alsa-plugins/issues/11
Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 jack/pcm_jack.c | 13 +++++++++++--
 1 file changed, 11 insertions(+), 2 deletions(-)

diff --git a/jack/pcm_jack.c b/jack/pcm_jack.c
index 26674fa..324da71 100644
--- a/jack/pcm_jack.c
+++ b/jack/pcm_jack.c
@@ -44,6 +44,7 @@ typedef struct {
 
 	int fd;
 	int activated;		/* jack is activated? */
+	int running;		/* jack is running? */
 
 	snd_pcm_jack_port_list_t **port_names;
 	unsigned int num_ports;
@@ -207,6 +208,9 @@ snd_pcm_jack_process_cb(jack_nframes_t nframes, snd_pcm_ioplug_t *io)
 	snd_pcm_jack_t *jack = io->private_data;
 	snd_pcm_uframes_t xfer = 0;
 	unsigned int channel;
+
+	if (!jack->running)
+		return 0;
 	
 	for (channel = 0; channel < io->channels; channel++) {
 		jack->areas[channel].addr = 
@@ -365,7 +369,9 @@ static int snd_pcm_jack_prepare(snd_pcm_ioplug_t *io)
 
 static int snd_pcm_jack_start(snd_pcm_ioplug_t *io)
 {
-	(void)io;
+	snd_pcm_jack_t *jack = io->private_data;
+
+	jack->running = jack->activated;
 	/*
 	 * Since the processing of jack_activate() and jack_connect() take a
 	 * while longer, snd_pcm_jack_start() was blocked.
@@ -382,7 +388,9 @@ static int snd_pcm_jack_start(snd_pcm_ioplug_t *io)
 
 static int snd_pcm_jack_stop(snd_pcm_ioplug_t *io)
 {
-	(void)io;
+	snd_pcm_jack_t *jack = io->private_data;
+
+	jack->running = 0;
 	return 0;
 }
 
@@ -394,6 +402,7 @@ static int snd_pcm_jack_hw_free(snd_pcm_ioplug_t *io)
 		jack_deactivate(jack->client);
 		jack->activated = 0;
 	}
+	jack->running = 0;
 #if 0
 	unsigned i;
 	for (i = 0; i < io->channels; i++) {
-- 
2.31.1


From 72b1bd9d228d6471e3cbb0ba341d7abf1748308b Mon Sep 17 00:00:00 2001
From: "Jerome M. Berger" <jeberger@free.fr>
Date: Mon, 14 Jun 2021 11:18:34 +0200
Subject: [PATCH 02/29] jack: Make the running state tracing code more robust
 to multi-thread access.

Fixes: https://github.com/alsa-project/alsa-plugins/issues/11
Fixes: 2352e4e ("jack: trace the running state")
Signed-off-by: "Jerome M. Berger" <jeberger@free.fr>
Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 jack/pcm_jack.c | 27 ++++++++++++++++++++++-----
 1 file changed, 22 insertions(+), 5 deletions(-)

diff --git a/jack/pcm_jack.c b/jack/pcm_jack.c
index 324da71..436aefe 100644
--- a/jack/pcm_jack.c
+++ b/jack/pcm_jack.c
@@ -28,6 +28,7 @@
 #include <jack/jack.h>
 #include <alsa/asoundlib.h>
 #include <alsa/pcm_external.h>
+#include <pthread.h>
 
 #define MAX_PERIODS_MULTIPLE 64
 
@@ -44,6 +45,7 @@ typedef struct {
 
 	int fd;
 	int activated;		/* jack is activated? */
+	pthread_mutex_t running_mutex;
 	int running;		/* jack is running? */
 
 	snd_pcm_jack_port_list_t **port_names;
@@ -160,6 +162,7 @@ static void snd_pcm_jack_free(snd_pcm_jack_t *jack)
 		free(jack->port_names);
 		jack->port_names = NULL;
 	}
+	pthread_mutex_destroy (&jack->running_mutex);
 	if (jack->fd >= 0)
 		close(jack->fd);
 	if (jack->io.poll_fd >= 0)
@@ -209,8 +212,17 @@ snd_pcm_jack_process_cb(jack_nframes_t nframes, snd_pcm_ioplug_t *io)
 	snd_pcm_uframes_t xfer = 0;
 	unsigned int channel;
 
-	if (!jack->running)
+	if (pthread_mutex_trylock (&jack->running_mutex) == EBUSY) {
+		/* Note that locking should only ever fail if
+		 * snd_pcm_jack_start or snd_pcm_jack_stop is called at the
+		 * same time, in which case dropping the current buffer is not
+		 * an issue. */
 		return 0;
+	}
+	if (!jack->running) {
+		pthread_mutex_unlock (&jack->running_mutex);
+		return 0;
+	}
 	
 	for (channel = 0; channel < io->channels; channel++) {
 		jack->areas[channel].addr = 
@@ -272,6 +284,8 @@ snd_pcm_jack_process_cb(jack_nframes_t nframes, snd_pcm_ioplug_t *io)
 
 	pcm_poll_unblock_check(io); /* unblock socket for polling if needed */
 
+	pthread_mutex_unlock (&jack->running_mutex);
+
 	return 0;
 }
 
@@ -370,8 +384,9 @@ static int snd_pcm_jack_prepare(snd_pcm_ioplug_t *io)
 static int snd_pcm_jack_start(snd_pcm_ioplug_t *io)
 {
 	snd_pcm_jack_t *jack = io->private_data;
-
-	jack->running = jack->activated;
+	pthread_mutex_lock (&jack->running_mutex);
+	jack->running = 1;
+	pthread_mutex_unlock (&jack->running_mutex);
 	/*
 	 * Since the processing of jack_activate() and jack_connect() take a
 	 * while longer, snd_pcm_jack_start() was blocked.
@@ -389,8 +404,9 @@ static int snd_pcm_jack_start(snd_pcm_ioplug_t *io)
 static int snd_pcm_jack_stop(snd_pcm_ioplug_t *io)
 {
 	snd_pcm_jack_t *jack = io->private_data;
-
+	pthread_mutex_lock (&jack->running_mutex);
 	jack->running = 0;
+	pthread_mutex_unlock (&jack->running_mutex);
 	return 0;
 }
 
@@ -402,7 +418,6 @@ static int snd_pcm_jack_hw_free(snd_pcm_ioplug_t *io)
 		jack_deactivate(jack->client);
 		jack->activated = 0;
 	}
-	jack->running = 0;
 #if 0
 	unsigned i;
 	for (i = 0; i < io->channels; i++) {
@@ -557,6 +572,8 @@ static int snd_pcm_jack_open(snd_pcm_t **pcmp, const char *name,
 	if (!jack)
 		return -ENOMEM;
 
+	pthread_mutex_init (&jack->running_mutex, NULL);
+
 	jack->fd = -1;
 	jack->io.poll_fd = -1;
 	jack->use_period_alignment = use_period_alignment;
-- 
2.31.1


From fcc45083ac3c216d7d5bcf6c180ef72258895824 Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Mon, 14 Jun 2021 16:07:25 +0200
Subject: [PATCH 03/29] jack: add -lpthread to Makefile

Fixes: 72b1bd9 ("jack: Make the running state tracing code more robust to multi-thread access.")
Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 jack/Makefile.am | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/jack/Makefile.am b/jack/Makefile.am
index 7801194..117a5c9 100644
--- a/jack/Makefile.am
+++ b/jack/Makefile.am
@@ -12,7 +12,7 @@ AM_CFLAGS = -Wall -g @ALSA_CFLAGS@ @JACK_CFLAGS@
 AM_LDFLAGS = -module -avoid-version -export-dynamic -no-undefined $(LDFLAGS_NOUNDEFINED)
 
 libasound_module_pcm_jack_la_SOURCES = pcm_jack.c
-libasound_module_pcm_jack_la_LIBADD = @ALSA_LIBS@ @JACK_LIBS@
+libasound_module_pcm_jack_la_LIBADD = @ALSA_LIBS@ @JACK_LIBS@ -lpthread
 
 include ../install-hooks.am
 
-- 
2.31.1


From 29f88436a7f3296d8ae78972d698a27196b37715 Mon Sep 17 00:00:00 2001
From: James Almer <jamrial@gmail.com>
Date: Sun, 6 Jun 2021 12:40:37 -0300
Subject: [PATCH 04/29] a52: add some padding bytes to outbuf

Since it's used as AVPacket payload, the API requires it to be padded.

BugLink: https://github.com/alsa-project/alsa-plugins/pull/23
Signed-off-by: James Almer <jamrial@gmail.com>
Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index b6a8f55..2ccc478 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -62,6 +62,12 @@
 #define AV_CODEC_ID_AC3 CODEC_ID_AC3
 #endif
 
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(56, 56, 0)
+#ifndef AV_INPUT_BUFFER_PADDING_SIZE
+#define AV_INPUT_BUFFER_PADDING_SIZE   FF_INPUT_BUFFER_PADDING_SIZE
+#endif
+#endif
+
 #if LIBAVCODEC_VERSION_INT < 0x371c01
 #define av_frame_alloc avcodec_alloc_frame
 #define av_frame_free avcodec_free_frame
@@ -623,9 +629,10 @@ static int a52_prepare(snd_pcm_ioplug_t *io)
 		return -EINVAL;
 
 	rec->outbuf_size = rec->avctx->frame_size * 4;
-	rec->outbuf = malloc(rec->outbuf_size);
+	rec->outbuf = malloc(rec->outbuf_size + AV_INPUT_BUFFER_PADDING_SIZE);
 	if (! rec->outbuf)
 		return -ENOMEM;
+	memset(rec->outbuf + rec->outbuf_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
 
 	if (alloc_input_buffer(io))
 		return -ENOMEM;
-- 
2.31.1


From 7d9d227a8443626c2525187d37dfe45a99fcbd13 Mon Sep 17 00:00:00 2001
From: James Almer <jamrial@gmail.com>
Date: Sun, 6 Jun 2021 14:38:11 -0300
Subject: [PATCH 05/29] a52: propagate errors from do_encode()

BugLink: https://github.com/alsa-project/alsa-plugins/pull/23
Signed-off-by: James Almer <jamrial@gmail.com>
Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 28 ++++++++++++++++++++++------
 1 file changed, 22 insertions(+), 6 deletions(-)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index 2ccc478..ecf7430 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -111,25 +111,35 @@ static int do_encode(struct a52_ctx *rec)
 		.data = rec->outbuf + 8,
 		.size = rec->outbuf_size - 8
 	};
-	int got_frame;
+	int ret, got_frame;
+
+	ret = avcodec_encode_audio2(rec->avctx, &pkt, rec->frame, &got_frame);
+	if (ret < 0)
+		return -EINVAL;
 
-	avcodec_encode_audio2(rec->avctx, &pkt, rec->frame, &got_frame);
 	return pkt.size;
 }
 #else
 static int do_encode(struct a52_ctx *rec)
 {
-	return avcodec_encode_audio(rec->avctx, rec->outbuf + 8,
+	int ret = avcodec_encode_audio(rec->avctx, rec->outbuf + 8,
 				    rec->outbuf_size - 8,
 				    rec->inbuf);
+	if (ret < 0)
+		return -EINVAL;
+
+	return ret;
 }
 #endif
 
 /* convert the PCM data to A52 stream in IEC958 */
-static void convert_data(struct a52_ctx *rec)
+static int convert_data(struct a52_ctx *rec)
 {
 	int out_bytes = do_encode(rec);
 
+	if (out_bytes < 0)
+		return out_bytes;
+
 	rec->outbuf[0] = 0xf8; /* sync words */
 	rec->outbuf[1] = 0x72;
 	rec->outbuf[2] = 0x4e;
@@ -145,6 +155,8 @@ static void convert_data(struct a52_ctx *rec)
 	       rec->outbuf_size - 8 - out_bytes);
 	rec->remain = rec->outbuf_size / 4;
 	rec->filled = 0;
+
+	return 0;
 }
 
 /* write pending encoded data to the slave pcm */
@@ -204,7 +216,9 @@ static int a52_drain(snd_pcm_ioplug_t *io)
 			memset(rec->inbuf + rec->filled * io->channels, 0,
 			       (rec->avctx->frame_size - rec->filled) * io->channels * 2);
 		}
-		convert_data(rec);
+		err = convert_data(rec);
+		if (err < 0)
+			return err;
 	}
 	err = write_out_pending(io, rec);
 	if (err < 0)
@@ -303,7 +317,9 @@ static int fill_data(snd_pcm_ioplug_t *io,
 	}
 	rec->filled += size;
 	if (rec->filled == rec->avctx->frame_size) {
-		convert_data(rec);
+		err = convert_data(rec);
+		if (err < 0)
+			return err;
 		write_out_pending(io, rec);
 	}
 	return (int)size;
-- 
2.31.1


From 166e308f08a8588efe654d9c4331c7056868c979 Mon Sep 17 00:00:00 2001
From: James Almer <jamrial@gmail.com>
Date: Sun, 6 Jun 2021 14:55:08 -0300
Subject: [PATCH 06/29] a52: support the new libavcodec encode API

ffmpeg 4.4 is the last version with avcodec_encode_audio2(). Starting from the
next release the new decoupled input-output API will be the only one available.

BugLink: https://github.com/alsa-project/alsa-plugins/pull/23
Signed-off-by: James Almer <jamrial@gmail.com>
Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 44 +++++++++++++++++++++++++++++++++++++++++++-
 1 file changed, 43 insertions(+), 1 deletion(-)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index ecf7430..816e5e3 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -44,6 +44,11 @@
 #define USE_AVCODEC_FRAME
 #endif
 
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(58, 93, 0)
+#include <libavcodec/packet.h>
+#define USE_AVCODEC_PACKET_ALLOC
+#endif
+
 #if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(54, 0, 0)
 #ifndef AV_CH_LAYOUT_STEREO
 #define AV_CH_LAYOUT_STEREO	CH_LAYOUT_STEREO
@@ -92,6 +97,9 @@ struct a52_ctx {
 	unsigned int slave_period_size;
 	unsigned int slave_buffer_size;
 	snd_pcm_hw_params_t *hw_params;
+#ifdef USE_AVCODEC_PACKET_ALLOC
+	AVPacket *pkt;
+#endif
 #ifdef USE_AVCODEC_FRAME
 	AVFrame *frame;
 	int is_planar;
@@ -104,7 +112,26 @@ struct a52_ctx {
 #define use_planar(rec)		0
 #endif
 
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(53, 34, 0)
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(58, 93, 0)
+static int do_encode(struct a52_ctx *rec)
+{
+	AVPacket *pkt = rec->pkt;
+	int ret;
+
+	ret = avcodec_send_frame(rec->avctx, rec->frame);
+	if (ret < 0)
+		return -EINVAL;
+	ret = avcodec_receive_packet(rec->avctx, pkt);
+	if (ret < 0)
+		return -EINVAL;
+
+	if (pkt->size > rec->outbuf_size - 8)
+		return -EINVAL;
+	memcpy(rec->outbuf + 8, pkt->data, pkt->size);
+
+	return pkt->size;
+}
+#elif LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(53, 34, 0)
 static int do_encode(struct a52_ctx *rec)
 {
 	AVPacket pkt = {
@@ -558,6 +585,9 @@ static void a52_free(struct a52_ctx *rec)
 #endif
 #endif
 
+#ifdef USE_AVCODEC_PACKET_ALLOC
+	av_packet_free(&rec->pkt);
+#endif
 	free(rec->inbuf);
 	rec->inbuf = NULL;
 	free(rec->outbuf);
@@ -603,6 +633,12 @@ static int alloc_input_buffer(snd_pcm_ioplug_t *io)
 			     io->channels, rec->avctx->frame_size,
 			     rec->avctx->sample_fmt, 0) < 0)
 		return -ENOMEM;
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(58, 93, 0)
+	rec->frame->extended_data = rec->frame->data;
+	rec->frame->format = rec->avctx->sample_fmt;
+	rec->frame->channels = rec->avctx->channels;
+	rec->frame->channel_layout = rec->avctx->channel_layout;
+#endif
 	rec->frame->nb_samples = rec->avctx->frame_size;
 	rec->inbuf = (short *)rec->frame->data[0];
 #else
@@ -644,6 +680,12 @@ static int a52_prepare(snd_pcm_ioplug_t *io)
 	if (err < 0)
 		return -EINVAL;
 
+#ifdef USE_AVCODEC_PACKET_ALLOC
+	rec->pkt = av_packet_alloc();
+	if (!rec->pkt)
+		return -ENOMEM;
+#endif
+
 	rec->outbuf_size = rec->avctx->frame_size * 4;
 	rec->outbuf = malloc(rec->outbuf_size + AV_INPUT_BUFFER_PADDING_SIZE);
 	if (! rec->outbuf)
-- 
2.31.1


From 8473252ae0c247ea663296ae3e51e9c00db8c0be Mon Sep 17 00:00:00 2001
From: James Almer <jamrial@gmail.com>
Date: Tue, 8 Jun 2021 17:08:41 -0300
Subject: [PATCH 07/29] a52: don't call avcodec_register_all() on newer
 libavocdec versions

It's no longer available starting with LIBAVCODEC_VERSION_MAJOR == 59.

BugLink: https://github.com/alsa-project/alsa-plugins/pull/23
Signed-off-by: James Almer <jamrial@gmail.com>
Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 2 ++
 1 file changed, 2 insertions(+)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index 816e5e3..14e444d 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -1004,7 +1004,9 @@ SND_PCM_PLUGIN_DEFINE_FUNC(a52)
 #ifndef USE_AVCODEC_FRAME
 	avcodec_init();
 #endif
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59, 0, 0)
 	avcodec_register_all();
+#endif
 
 	rec->codec = avcodec_find_encoder_by_name("ac3_fixed");
 	if (rec->codec == NULL)
-- 
2.31.1


From c12a6ae73e10673901ff9fc7da236e6f68f74aef Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Tue, 15 Jun 2021 15:25:47 +0200
Subject: [PATCH 08/29] a52: limit the number of periods for ioplug from slave
 PCM

Intel HDMI:

  PERIOD_SIZE: [32 4272000]
  PERIOD_BYTES: [128 17088000]
  PERIODS: [2 32]
  BUFFER_SIZE: [64 8544000]
  BUFFER_BYTES: [256 34176000]

Selected:

  PERIOD_SIZE: 768
  PERIOD_BYTES: 3072
  PERIODS: 32
  BUFFER_SIZE: 24576
  BUFFER_BYTES: 98304

The a52_hw_params() tries to set the big 4271616 buffer size (frames)
for speaker-test which is beyond the maximal slave buffer.

BugLink: https://github.com/alsa-project/alsa-plugins/pull/23
Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 7 +++++--
 1 file changed, 5 insertions(+), 2 deletions(-)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index 14e444d..76511bf 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -839,7 +839,7 @@ static int a52_set_hw_constraint(struct a52_ctx *rec)
 		SND_PCM_ACCESS_RW_NONINTERLEAVED
 	};
 	unsigned int formats[] = { SND_PCM_FORMAT_S16 };
-	int err;
+	int err, dir;
 	snd_pcm_uframes_t buffer_max;
 	unsigned int period_bytes, max_periods;
 
@@ -868,8 +868,11 @@ static int a52_set_hw_constraint(struct a52_ctx *rec)
 		return err;
 
 	snd_pcm_hw_params_get_buffer_size_max(rec->hw_params, &buffer_max);
+	dir = -1;
+	snd_pcm_hw_params_get_periods_max(rec->hw_params, &max_periods, &dir);
 	period_bytes = A52_FRAME_SIZE * 2 * rec->channels;
-	max_periods = buffer_max / A52_FRAME_SIZE;
+	if (buffer_max / A52_FRAME_SIZE < max_periods)
+		max_periods = buffer_max / A52_FRAME_SIZE;
 
 	if ((err = snd_pcm_ioplug_set_param_minmax(&rec->io, SND_PCM_IOPLUG_HW_PERIOD_BYTES,
 						   period_bytes, period_bytes)) < 0 ||
-- 
2.31.1


From f11e7a8994111f971bc881d4069f768472452f4f Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Mon, 14 Jun 2021 16:35:17 +0200
Subject: [PATCH 09/29] a52: handle the source sample format correctly

The recent a52 encoder in ffmpeg accepts planar S32 (fixed encoder)
or planar float (normal encoder) only. Extend the routines to support
all combinations of 16-bit, 32-bit and float source samples.

BugLink: https://github.com/alsa-project/alsa-plugins/pull/23
Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 110 ++++++++++++++++++++++++++++++++++++++------------
 1 file changed, 84 insertions(+), 26 deletions(-)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index 76511bf..b1a07b4 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -41,7 +41,7 @@
 #if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(53, 34, 0)
 #include <libavutil/channel_layout.h>
 #include <libavutil/mem.h>
-#define USE_AVCODEC_FRAME
+#define USE_AVCODEC_FRAME 1
 #endif
 
 #if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(58, 93, 0)
@@ -83,12 +83,15 @@ struct a52_ctx {
 	snd_pcm_t *slave;
 	AVCodec *codec;
 	AVCodecContext *avctx;
+	snd_pcm_format_t src_format;
+	unsigned int src_sample_bits;
+	unsigned int src_sample_bytes;
 	snd_pcm_format_t format;
 	int av_format;
 	unsigned int channels;
 	unsigned int rate;
 	unsigned int bitrate;
-	short *inbuf;
+	void *inbuf;
 	unsigned char *outbuf;
 	int outbuf_size;
 	snd_pcm_uframes_t transfer;
@@ -150,8 +153,8 @@ static int do_encode(struct a52_ctx *rec)
 static int do_encode(struct a52_ctx *rec)
 {
 	int ret = avcodec_encode_audio(rec->avctx, rec->outbuf + 8,
-				    rec->outbuf_size - 8,
-				    rec->inbuf);
+				       rec->outbuf_size - 8,
+				       rec->inbuf);
 	if (ret < 0)
 		return -EINVAL;
 
@@ -221,8 +224,8 @@ static void clear_remaining_planar_data(snd_pcm_ioplug_t *io)
 	unsigned int i;
 
 	for (i = 0; i < io->channels; i++)
-		memset(rec->frame->data[i] + rec->filled * 2, 0,
-		       (rec->avctx->frame_size - rec->filled) * 2);
+		memset(rec->frame->data[i] + rec->filled * rec->src_sample_bytes, 0,
+		       (rec->avctx->frame_size - rec->filled) * rec->src_sample_bytes);
 }
 #else
 #define clear_remaining_planar_data(io) /*NOP*/
@@ -240,8 +243,8 @@ static int a52_drain(snd_pcm_ioplug_t *io)
 		if (use_planar(rec))
 			clear_remaining_planar_data(io);
 		else {
-			memset(rec->inbuf + rec->filled * io->channels, 0,
-			       (rec->avctx->frame_size - rec->filled) * io->channels * 2);
+			memset(rec->inbuf + rec->filled * io->channels * rec->src_sample_bytes, 0,
+			       (rec->avctx->frame_size - rec->filled) * io->channels * rec->src_sample_bytes);
 		}
 		err = convert_data(rec);
 		if (err < 0)
@@ -255,7 +258,8 @@ static int a52_drain(snd_pcm_ioplug_t *io)
 }
 
 /* check whether the areas consist of a continuous interleaved stream */
-static int check_interleaved(const snd_pcm_channel_area_t *areas,
+static int check_interleaved(struct a52_ctx *rec,
+			     const snd_pcm_channel_area_t *areas,
 			     unsigned int channels)
 {
 	unsigned int ch;
@@ -265,8 +269,8 @@ static int check_interleaved(const snd_pcm_channel_area_t *areas,
 
 	for (ch = 0; ch < channels; ch++) {
 		if (areas[ch].addr != areas[0].addr ||
-		    areas[ch].first != ch * 16 ||
-		    areas[ch].step != channels * 16)
+		    areas[ch].first != ch * rec->src_sample_bits ||
+		    areas[ch].step != channels * rec->src_sample_bits)
 			return 0;
 	}
 	return 1;
@@ -284,8 +288,7 @@ static int fill_data(snd_pcm_ioplug_t *io,
 {
 	struct a52_ctx *rec = io->private_data;
 	unsigned int len = rec->avctx->frame_size - rec->filled;
-	short *src, *dst;
-	unsigned int src_step;
+	void *_dst;
 	int err;
 	static unsigned int ch_index[3][6] = {
 		{ 0, 1 },
@@ -311,13 +314,13 @@ static int fill_data(snd_pcm_ioplug_t *io,
 	if (size > len)
 		size = len;
 
-	dst = rec->inbuf + rec->filled * io->channels;
+	_dst = rec->inbuf + rec->filled * io->channels * rec->src_sample_bytes;
 	if (!use_planar(rec) && interleaved) {
-		memcpy(dst, areas->addr + offset * io->channels * 2,
-		       size * io->channels * 2);
-	} else {
-		unsigned int i, ch, dst_step;
-		short *dst1;
+		memcpy(_dst, areas->addr + offset * io->channels * rec->src_sample_bytes,
+		       size * io->channels * rec->src_sample_bytes);
+	} else if (rec->src_sample_bits == 16) {
+		unsigned int i, ch, src_step, dst_step;
+		short *src, *dst = _dst, *dst1;
 
 		/* flatten copy to n-channel interleaved */
 		dst_step = io->channels;
@@ -328,8 +331,8 @@ static int fill_data(snd_pcm_ioplug_t *io,
 					(ap->first + offset * ap->step) / 8);
 
 #ifdef USE_AVCODEC_FRAME
-			if (use_planar(rec)) {
-				memcpy(rec->frame->data[ch], src, size * 2);
+			if (use_planar(rec) && !interleaved) {
+				memcpy(rec->frame->data[ch] + rec->filled, src, size * 2);
 				continue;
 			}
 #endif
@@ -341,6 +344,34 @@ static int fill_data(snd_pcm_ioplug_t *io,
 				dst1 += dst_step;
 			}
 		}
+	} else if (rec->src_sample_bits == 32) {
+		unsigned int i, ch, src_step, dst_step;
+		int *src, *dst = _dst, *dst1;
+
+		/* flatten copy to n-channel interleaved */
+		dst_step = io->channels;
+		for (ch = 0; ch < io->channels; ch++, dst++) {
+			const snd_pcm_channel_area_t *ap;
+			ap = &areas[ch_index[io->channels / 2 - 1][ch]];
+			src = (int *)(ap->addr +
+					(ap->first + offset * ap->step) / 8);
+
+#ifdef USE_AVCODEC_FRAME
+			if (use_planar(rec) && !interleaved) {
+				memcpy(rec->frame->data[ch] + rec->filled, src, size * 4);
+				continue;
+			}
+#endif
+			dst1 = dst;
+			src_step = ap->step / 32; /* in word */
+			for (i = 0; i < size; i++) {
+				*dst1 = *src;
+				src += src_step;
+				dst1 += dst_step;
+			}
+		}
+	} else {
+		return -EIO;
 	}
 	rec->filled += size;
 	if (rec->filled == rec->avctx->frame_size) {
@@ -363,7 +394,7 @@ static snd_pcm_sframes_t a52_transfer(snd_pcm_ioplug_t *io,
 	struct a52_ctx *rec = io->private_data;
 	snd_pcm_sframes_t result = 0;
 	int err = 0;
-	int interleaved = check_interleaved(areas, io->channels);
+	int interleaved = check_interleaved(rec, areas, io->channels);
 
 	do {
 		err = fill_data(io, areas, offset, size, interleaved);
@@ -640,9 +671,9 @@ static int alloc_input_buffer(snd_pcm_ioplug_t *io)
 	rec->frame->channel_layout = rec->avctx->channel_layout;
 #endif
 	rec->frame->nb_samples = rec->avctx->frame_size;
-	rec->inbuf = (short *)rec->frame->data[0];
+	rec->inbuf = rec->frame->data[0];
 #else
-	rec->inbuf = malloc(rec->avctx->frame_size * 2 * io->channels);
+	rec->inbuf = malloc(rec->avctx->frame_size * io->channels * rec->src_sample_bytes);
 #endif
 	if (!rec->inbuf)
 		return -ENOMEM;
@@ -838,8 +869,20 @@ static int a52_set_hw_constraint(struct a52_ctx *rec)
 		SND_PCM_ACCESS_MMAP_NONINTERLEAVED,
 		SND_PCM_ACCESS_RW_NONINTERLEAVED
 	};
-	unsigned int formats[] = { SND_PCM_FORMAT_S16 };
+	static struct format {
+		unsigned int av;
+		snd_pcm_format_t alib;
+	} formats[] = {
+		{ .av = AV_SAMPLE_FMT_S16, .alib = SND_PCM_FORMAT_S16 },
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(52, 95, 0) && USE_AVCODEC_FRAME
+		{ .av = AV_SAMPLE_FMT_S16P, .alib = SND_PCM_FORMAT_S16 },
+		{ .av = AV_SAMPLE_FMT_S32, .alib = SND_PCM_FORMAT_S32 },
+		{ .av = AV_SAMPLE_FMT_S32P, .alib = SND_PCM_FORMAT_S32 },
+		{ .av = AV_SAMPLE_FMT_FLTP, .alib = SND_PCM_FORMAT_FLOAT }
+#endif
+	};
 	int err, dir;
+	unsigned int i, fmt;
 	snd_pcm_uframes_t buffer_max;
 	unsigned int period_bytes, max_periods;
 
@@ -856,8 +899,22 @@ static int a52_set_hw_constraint(struct a52_ctx *rec)
 	if (err < 0)
 		return err;
 
+	rec->src_format = SND_PCM_FORMAT_UNKNOWN;
+	for (i = 0; i < ARRAY_SIZE(formats); i++)
+		if (formats[i].av == rec->av_format) {
+			rec->src_format = formats[i].alib;
+			break;
+		}
+	if (rec->src_format == SND_PCM_FORMAT_UNKNOWN) {
+		SNDERR("A/V format '%s' is not supported", av_get_sample_fmt_name(rec->av_format));
+		return -EINVAL;
+	}
+	fmt = rec->src_format;
+	rec->src_sample_bits = snd_pcm_format_physical_width(rec->src_format);
+	rec->src_sample_bytes = rec->src_sample_bits / 8;
+
 	if ((err = snd_pcm_ioplug_set_param_list(&rec->io, SND_PCM_IOPLUG_HW_FORMAT,
-						 ARRAY_SIZE(formats), formats)) < 0 ||
+						 1, &fmt)) < 0 ||
 	    (err = snd_pcm_ioplug_set_param_minmax(&rec->io, SND_PCM_IOPLUG_HW_CHANNELS,
 						   rec->channels, rec->channels)) < 0 ||
 	    (err = snd_pcm_ioplug_set_param_minmax(&rec->io, SND_PCM_IOPLUG_HW_RATE,
@@ -999,6 +1056,7 @@ SND_PCM_PLUGIN_DEFINE_FUNC(a52)
 		return -ENOMEM;
 	}
 
+	rec->src_format = SND_PCM_FORMAT_UNKNOWN;
 	rec->rate = rate;
 	rec->bitrate = bitrate;
 	rec->channels = channels;
-- 
2.31.1


From 3726d49ba537c1546782a62ba0b29db09004ea7c Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Tue, 15 Jun 2021 19:31:18 +0200
Subject: [PATCH 10/29] a52: Correct data transfer in planar mode

The buffer offset was incorrectly calculated in samples.

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 a52/pcm_a52.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index b1a07b4..95d2c3f 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -332,7 +332,7 @@ static int fill_data(snd_pcm_ioplug_t *io,
 
 #ifdef USE_AVCODEC_FRAME
 			if (use_planar(rec) && !interleaved) {
-				memcpy(rec->frame->data[ch] + rec->filled, src, size * 2);
+				memcpy(rec->frame->data[ch] + rec->filled * 2, src, size * 2);
 				continue;
 			}
 #endif
@@ -358,7 +358,7 @@ static int fill_data(snd_pcm_ioplug_t *io,
 
 #ifdef USE_AVCODEC_FRAME
 			if (use_planar(rec) && !interleaved) {
-				memcpy(rec->frame->data[ch] + rec->filled, src, size * 4);
+				memcpy(rec->frame->data[ch] + rec->filled * 4, src, size * 4);
 				continue;
 			}
 #endif
-- 
2.31.1


From 1d7ede949730c6284e2b9f03804c8f7345fa768a Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Tue, 15 Jun 2021 19:32:17 +0200
Subject: [PATCH 11/29] a52: Use av_frame_get_buffer() for buffer allocation

A more modern one for the recent API.

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 a52/pcm_a52.c | 27 +++++++++++++++------------
 1 file changed, 15 insertions(+), 12 deletions(-)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index 95d2c3f..16ac722 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -605,22 +605,23 @@ static void a52_free(struct a52_ctx *rec)
 	}
 
 #ifdef USE_AVCODEC_FRAME
-	if (rec->frame) {
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 93, 0)
+	if (rec->frame)
 		av_freep(&rec->frame->data[0]);
-		rec->inbuf = NULL;
-	}
+#endif
 #if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(54, 28, 0)
 	av_frame_free(&rec->frame);
 #else
 	av_freep(&rec->frame);
 #endif
-#endif
+#else /* USE_AVCODEC_FRAME */
+	free(rec->inbuf);
+	rec->inbuf = NULL;
+#endif /* USE_AVCODEC_FRAME */
 
 #ifdef USE_AVCODEC_PACKET_ALLOC
 	av_packet_free(&rec->pkt);
 #endif
-	free(rec->inbuf);
-	rec->inbuf = NULL;
 	free(rec->outbuf);
 	rec->outbuf = NULL;
 }
@@ -660,17 +661,19 @@ static int alloc_input_buffer(snd_pcm_ioplug_t *io)
 	rec->frame = av_frame_alloc();
 	if (!rec->frame)
 		return -ENOMEM;
-	if (av_samples_alloc(rec->frame->data, rec->frame->linesize,
-			     io->channels, rec->avctx->frame_size,
-			     rec->avctx->sample_fmt, 0) < 0)
-		return -ENOMEM;
+	rec->frame->nb_samples = rec->avctx->frame_size;
 #if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(58, 93, 0)
-	rec->frame->extended_data = rec->frame->data;
 	rec->frame->format = rec->avctx->sample_fmt;
 	rec->frame->channels = rec->avctx->channels;
 	rec->frame->channel_layout = rec->avctx->channel_layout;
+	if (av_frame_get_buffer(rec->frame, 0))
+		return -ENOMEM;
+#else
+	if (av_samples_alloc(rec->frame->data, rec->frame->linesize,
+			     io->channels, rec->avctx->frame_size,
+			     rec->avctx->sample_fmt, 0) < 0)
+		return -ENOMEM;
 #endif
-	rec->frame->nb_samples = rec->avctx->frame_size;
 	rec->inbuf = rec->frame->data[0];
 #else
 	rec->inbuf = malloc(rec->avctx->frame_size * io->channels * rec->src_sample_bytes);
-- 
2.31.1


From e6d10b67d0bce636cbeedc063dfed9ce7eb5a3ce Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Wed, 16 Jun 2021 09:29:56 +0200
Subject: [PATCH 12/29] a52: allow to specify the avcodec

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 21 ++++++++++++++++++---
 1 file changed, 18 insertions(+), 3 deletions(-)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index 16ac722..9b5d135 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -952,6 +952,7 @@ SND_PCM_PLUGIN_DEFINE_FUNC(a52)
 	int err;
 	const char *card = NULL;
 	const char *pcm_string = NULL;
+	const char *avcodec = NULL;
 	unsigned int rate = 48000;
 	unsigned int bitrate = 448;
 	unsigned int channels = 6;
@@ -1049,6 +1050,16 @@ SND_PCM_PLUGIN_DEFINE_FUNC(a52)
 			}
 			continue;
 		}
+		if (strcmp(id, "avcodec") == 0) {
+			const char *str;
+			err = snd_config_get_string(n, &str);
+			if (err < 0) {
+				SNDERR("invalid type for %s", id);
+				return -EINVAL;
+			}
+			avcodec = str;
+			continue;
+		}
 		SNDERR("Unknown field %s", id);
 		return -EINVAL;
 	}
@@ -1072,9 +1083,13 @@ SND_PCM_PLUGIN_DEFINE_FUNC(a52)
 	avcodec_register_all();
 #endif
 
-	rec->codec = avcodec_find_encoder_by_name("ac3_fixed");
-	if (rec->codec == NULL)
-		rec->codec = avcodec_find_encoder_by_name("ac3");
+	if (avcodec) {
+		rec->codec = avcodec_find_encoder_by_name(avcodec);
+	} else {
+		rec->codec = avcodec_find_encoder_by_name("ac3_fixed");
+		if (rec->codec == NULL)
+			rec->codec = avcodec_find_encoder_by_name("ac3");
+	}
 	if (rec->codec == NULL) 
 		rec->codec = avcodec_find_encoder(AV_CODEC_ID_AC3);
 	if (rec->codec == NULL) {
-- 
2.31.1


From 5345ee803c531e2ef38357886c721a7cefda07f6 Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Wed, 16 Jun 2021 09:41:34 +0200
Subject: [PATCH 13/29] a52: implement dump callback to dump the output
 parameters

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 16 ++++++++++++++++
 1 file changed, 16 insertions(+)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index 9b5d135..a6b04a1 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -542,6 +542,21 @@ static int a52_hw_free(snd_pcm_ioplug_t *io)
 	return snd_pcm_hw_free(rec->slave);
 }
 
+/*
+ * dump callback
+ */
+static int a52_dump(snd_pcm_ioplug_t *io, snd_output_t *out)
+{
+	struct a52_ctx *rec = io->private_data;
+	snd_pcm_t *pcm = io->pcm;
+
+	snd_output_printf(out, "%s\n", io->name);
+	snd_output_printf(out, "Its setup is:\n");
+	snd_pcm_dump_setup(pcm, out);
+	snd_output_printf(out, "Slave: ");
+	snd_pcm_dump(rec->slave, out);
+}
+
 /*
  * sw_params callback
  *
@@ -836,6 +851,7 @@ static snd_pcm_ioplug_callback_t a52_ops = {
 	.close = a52_close,
 	.hw_params = a52_hw_params,
 	.hw_free = a52_hw_free,
+	.dump = a52_dump,
 	.sw_params = a52_sw_params,
 	.prepare = a52_prepare,
 	.drain = a52_drain,
-- 
2.31.1


From df80b70013d3bd36aba13c79e1de7182a6aa4496 Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Wed, 16 Jun 2021 10:36:17 +0200
Subject: [PATCH 14/29] a52: fix possible string overflow and double space

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index a6b04a1..e48489e 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -973,7 +973,7 @@ SND_PCM_PLUGIN_DEFINE_FUNC(a52)
 	unsigned int bitrate = 448;
 	unsigned int channels = 6;
 	snd_pcm_format_t format = SND_PCM_FORMAT_S16_LE;
-	char devstr[128], tmpcard[8];
+	char devstr[128], tmpcard[16];
 	struct a52_ctx *rec;
 	
 	if (stream != SND_PCM_STREAM_PLAYBACK) {
@@ -1116,7 +1116,7 @@ SND_PCM_PLUGIN_DEFINE_FUNC(a52)
 
 	if (! pcm_string || pcm_string[0] == '\0') {
 		snprintf(devstr, sizeof(devstr),
-			 "iec958:{AES0 0x%x AES1 0x%x AES2 0x%x AES3 0x%x %s%s}",
+			 "iec958:{AES0 0x%x AES1 0x%x AES2 0x%x AES3 0x%x%s%s}",
 			 IEC958_AES0_CON_EMPHASIS_NONE | IEC958_AES0_NONAUDIO |
 			 IEC958_AES0_CON_NOT_COPYRIGHT,
 			 IEC958_AES1_CON_ORIGINAL | IEC958_AES1_CON_PCM_CODER,
-- 
2.31.1


From bdeee4b685db10525fd7ce4b88a7b5a7f9921f95 Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Wed, 16 Jun 2021 10:57:49 +0200
Subject: [PATCH 15/29] a52: cleanup write_out_pending() function

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 20 ++++++++++----------
 1 file changed, 10 insertions(+), 10 deletions(-)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index e48489e..2edc0a5 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -192,24 +192,24 @@ static int convert_data(struct a52_ctx *rec)
 /* write pending encoded data to the slave pcm */
 static int write_out_pending(snd_pcm_ioplug_t *io, struct a52_ctx *rec)
 {
-	int err, ofs = (rec->avctx->frame_size - rec->remain) * 4;
+	snd_pcm_sframes_t ret;
+	unsigned int ofs;
 
 	if (! rec->remain)
 		return 0;
 
 	while (rec->remain) {
-		err = snd_pcm_writei(rec->slave, rec->outbuf + ofs, rec->remain);
-		if (err < 0) {
-			if (err == -EPIPE)
+		ofs = (rec->avctx->frame_size - rec->remain) * 4;
+		ret = snd_pcm_writei(rec->slave, rec->outbuf + ofs, rec->remain);
+		if (ret < 0) {
+			if (ret == -EPIPE)
 				io->state = SND_PCM_STATE_XRUN;
-			if (err == -EAGAIN)
+			if (ret == -EAGAIN)
 				break;
-			return err;
-		} else if (! err)
+			return ret;
+		} else if (! ret)
 			break;
-		if (err < rec->remain)
-			ofs += (rec->remain - err) * 4;
-		rec->remain -= err;
+		rec->remain -= ret;
 	}
 	return 0;
 }
-- 
2.31.1


From e5ea76020863be3285ee2338710691431d701eeb Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Wed, 16 Jun 2021 16:57:34 +0200
Subject: [PATCH 16/29] a52: the dump callback should be void

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index 2edc0a5..f149373 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -545,7 +545,7 @@ static int a52_hw_free(snd_pcm_ioplug_t *io)
 /*
  * dump callback
  */
-static int a52_dump(snd_pcm_ioplug_t *io, snd_output_t *out)
+static void a52_dump(snd_pcm_ioplug_t *io, snd_output_t *out)
 {
 	struct a52_ctx *rec = io->private_data;
 	snd_pcm_t *pcm = io->pcm;
-- 
2.31.1


From 60e3f9ac9aa31424a88cff3eb3dc14e83d6f271c Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Wed, 16 Jun 2021 17:03:11 +0200
Subject: [PATCH 17/29] a52: add more info lines to the dump function

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index f149373..d4af5c5 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -553,6 +553,10 @@ static void a52_dump(snd_pcm_ioplug_t *io, snd_output_t *out)
 	snd_output_printf(out, "%s\n", io->name);
 	snd_output_printf(out, "Its setup is:\n");
 	snd_pcm_dump_setup(pcm, out);
+	snd_output_printf(out, "  %-13s: %s\n", "av_format", av_get_sample_fmt_name(rec->av_format));
+	snd_output_printf(out, "  %-13s: %i\n", "av_frame_size", rec->avctx->frame_size);
+	snd_output_printf(out, "  %-13s: %i\n", "remain", rec->remain);
+	snd_output_printf(out, "  %-13s: %i\n", "filled", rec->filled);
 	snd_output_printf(out, "Slave: ");
 	snd_pcm_dump(rec->slave, out);
 }
-- 
2.31.1


From 4dbbfba4e7556124478f010dcaf67c06b6ee6c99 Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Wed, 16 Jun 2021 17:08:11 +0200
Subject: [PATCH 18/29] a52: the packet alloc is suppoted since 58.91.0
 (proved)

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index d4af5c5..0105f92 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -44,7 +44,7 @@
 #define USE_AVCODEC_FRAME 1
 #endif
 
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(58, 93, 0)
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(58, 91, 0)
 #include <libavcodec/packet.h>
 #define USE_AVCODEC_PACKET_ALLOC
 #endif
@@ -115,7 +115,7 @@ struct a52_ctx {
 #define use_planar(rec)		0
 #endif
 
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(58, 93, 0)
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(58, 91, 0)
 static int do_encode(struct a52_ctx *rec)
 {
 	AVPacket *pkt = rec->pkt;
@@ -624,7 +624,7 @@ static void a52_free(struct a52_ctx *rec)
 	}
 
 #ifdef USE_AVCODEC_FRAME
-#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 93, 0)
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 91, 0)
 	if (rec->frame)
 		av_freep(&rec->frame->data[0]);
 #endif
@@ -681,7 +681,7 @@ static int alloc_input_buffer(snd_pcm_ioplug_t *io)
 	if (!rec->frame)
 		return -ENOMEM;
 	rec->frame->nb_samples = rec->avctx->frame_size;
-#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(58, 93, 0)
+#if LIBAVCODEC_VERSION_INT >= AV_VERSION_INT(58, 91, 0)
 	rec->frame->format = rec->avctx->sample_fmt;
 	rec->frame->channels = rec->avctx->channels;
 	rec->frame->channel_layout = rec->avctx->channel_layout;
-- 
2.31.1


From ef4fda2d5afb0eebced058d5704e33e4216f706f Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Wed, 16 Jun 2021 17:09:38 +0200
Subject: [PATCH 19/29] a52: don't call avcodec_register_all() for 58.91.0
 (proved)

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index 0105f92..6ada983 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -1099,7 +1099,7 @@ SND_PCM_PLUGIN_DEFINE_FUNC(a52)
 #ifndef USE_AVCODEC_FRAME
 	avcodec_init();
 #endif
-#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(59, 0, 0)
+#if LIBAVCODEC_VERSION_INT < AV_VERSION_INT(58, 91, 0)
 	avcodec_register_all();
 #endif
 
-- 
2.31.1


From d5d648a705c15445bec93f422b47d8633e66f308 Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Wed, 16 Jun 2021 17:11:45 +0200
Subject: [PATCH 20/29] a52: fix two signess warnings

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index 6ada983..f2d6747 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -446,7 +446,7 @@ static snd_pcm_sframes_t a52_pointer(snd_pcm_ioplug_t *io)
 
 	if (avail < 0)
 		avail = 0;
-	else if (avail >= io->buffer_size)
+	else if ((snd_pcm_uframes_t)avail >= io->buffer_size)
 		avail = io->buffer_size - 1;
 
 	return (io->appl_ptr + avail) % io->buffer_size;
@@ -893,7 +893,7 @@ static int a52_set_hw_constraint(struct a52_ctx *rec)
 		SND_PCM_ACCESS_RW_NONINTERLEAVED
 	};
 	static struct format {
-		unsigned int av;
+		int av;
 		snd_pcm_format_t alib;
 	} formats[] = {
 		{ .av = AV_SAMPLE_FMT_S16, .alib = SND_PCM_FORMAT_S16 },
-- 
2.31.1


From d9ac3f333f69cecf1914a0a265fb96195afc2c2a Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Wed, 16 Jun 2021 17:29:38 +0200
Subject: [PATCH 21/29] a52: fix restricted parameter for swab()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

pcm_a52.c: In function ‘convert_data’:
pcm_a52.c:183:24: warning: passing argument 2 to ‘restrict’-qualified parameter aliases with argument 1 [-Wrestrict]
  183 |   swab(rec->outbuf, rec->outbuf, out_bytes + 8);
      |        ~~~~~~~~~~~  ~~~^~~~~~~~

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 53 +++++++++++++++++++++++++++++++++------------------
 1 file changed, 34 insertions(+), 19 deletions(-)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index f2d6747..6aae56a 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -93,6 +93,8 @@ struct a52_ctx {
 	unsigned int bitrate;
 	void *inbuf;
 	unsigned char *outbuf;
+	unsigned char *outbuf1;
+	unsigned char *outbuf2;
 	int outbuf_size;
 	snd_pcm_uframes_t transfer;
 	int remain;
@@ -130,7 +132,7 @@ static int do_encode(struct a52_ctx *rec)
 
 	if (pkt->size > rec->outbuf_size - 8)
 		return -EINVAL;
-	memcpy(rec->outbuf + 8, pkt->data, pkt->size);
+	memcpy(rec->outbuf1 + 8, pkt->data, pkt->size);
 
 	return pkt->size;
 }
@@ -138,7 +140,7 @@ static int do_encode(struct a52_ctx *rec)
 static int do_encode(struct a52_ctx *rec)
 {
 	AVPacket pkt = {
-		.data = rec->outbuf + 8,
+		.data = rec->outbuf1 + 8,
 		.size = rec->outbuf_size - 8
 	};
 	int ret, got_frame;
@@ -152,7 +154,7 @@ static int do_encode(struct a52_ctx *rec)
 #else
 static int do_encode(struct a52_ctx *rec)
 {
-	int ret = avcodec_encode_audio(rec->avctx, rec->outbuf + 8,
+	int ret = avcodec_encode_audio(rec->avctx, rec->outbuf1 + 8,
 				       rec->outbuf_size - 8,
 				       rec->inbuf);
 	if (ret < 0)
@@ -165,23 +167,28 @@ static int do_encode(struct a52_ctx *rec)
 /* convert the PCM data to A52 stream in IEC958 */
 static int convert_data(struct a52_ctx *rec)
 {
+	unsigned char *buf;
 	int out_bytes = do_encode(rec);
 
 	if (out_bytes < 0)
 		return out_bytes;
 
-	rec->outbuf[0] = 0xf8; /* sync words */
-	rec->outbuf[1] = 0x72;
-	rec->outbuf[2] = 0x4e;
-	rec->outbuf[3] = 0x1f;
-	rec->outbuf[4] = rec->outbuf[13] & 7; /* bsmod */
-	rec->outbuf[5] = 0x01; /* data type */
-	rec->outbuf[6] = ((out_bytes * 8) >> 8) & 0xff;
-	rec->outbuf[7] = (out_bytes * 8) & 0xff;
+	buf = rec->outbuf1;
+	buf[0] = 0xf8; /* sync words */
+	buf[1] = 0x72;
+	buf[2] = 0x4e;
+	buf[3] = 0x1f;
+	buf[4] = buf[13] & 7; /* bsmod */
+	buf[5] = 0x01; /* data type */
+	buf[6] = ((out_bytes * 8) >> 8) & 0xff;
+	buf[7] = (out_bytes * 8) & 0xff;
 	/* swap bytes for little-endian 16bit */
-	if (rec->format == SND_PCM_FORMAT_S16_LE)
-		swab(rec->outbuf, rec->outbuf, out_bytes + 8);
-	memset(rec->outbuf +  8 + out_bytes, 0,
+	if (rec->format == SND_PCM_FORMAT_S16_LE) {
+		swab(rec->outbuf1, rec->outbuf2, out_bytes + 8);
+		buf = rec->outbuf2;
+	}
+	rec->outbuf = buf;
+	memset(buf + 8 + out_bytes, 0,
 	       rec->outbuf_size - 8 - out_bytes);
 	rec->remain = rec->outbuf_size / 4;
 	rec->filled = 0;
@@ -641,8 +648,10 @@ static void a52_free(struct a52_ctx *rec)
 #ifdef USE_AVCODEC_PACKET_ALLOC
 	av_packet_free(&rec->pkt);
 #endif
-	free(rec->outbuf);
-	rec->outbuf = NULL;
+	free(rec->outbuf2);
+	rec->outbuf2 = NULL;
+	free(rec->outbuf1);
+	rec->outbuf1 = NULL;
 }
 
 /*
@@ -740,10 +749,16 @@ static int a52_prepare(snd_pcm_ioplug_t *io)
 #endif
 
 	rec->outbuf_size = rec->avctx->frame_size * 4;
-	rec->outbuf = malloc(rec->outbuf_size + AV_INPUT_BUFFER_PADDING_SIZE);
-	if (! rec->outbuf)
+	rec->outbuf1 = malloc(rec->outbuf_size + AV_INPUT_BUFFER_PADDING_SIZE);
+	if (! rec->outbuf1)
 		return -ENOMEM;
-	memset(rec->outbuf + rec->outbuf_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
+	memset(rec->outbuf1 + rec->outbuf_size, 0, AV_INPUT_BUFFER_PADDING_SIZE);
+
+	if (rec->format == SND_PCM_FORMAT_S16_LE) {
+		rec->outbuf2 = malloc(rec->outbuf_size);
+		if ( !rec->outbuf2)
+			return -ENOMEM;
+	}
 
 	if (alloc_input_buffer(io))
 		return -ENOMEM;
-- 
2.31.1


From 1aa625a537fffe833cecc1ad71f8390e8a5e0dbe Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Wed, 16 Jun 2021 17:47:52 +0200
Subject: [PATCH 22/29] a52: fix memory leak in the close callback

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index 6aae56a..d28c8c3 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -802,10 +802,9 @@ static int a52_close(snd_pcm_ioplug_t *io)
 	snd_pcm_t *slave = rec->slave;
 
 	a52_free(rec);
-	if (slave) {
-		rec->slave = NULL;
+	free(rec);
+	if (slave)
 		return snd_pcm_close(slave);
-	}
 	return 0;
 }
 			      
-- 
2.31.1


From 8a3c0d795fbef5700c8cedcc82c6a337170c76ee Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Wed, 16 Jun 2021 10:21:35 +0200
Subject: [PATCH 23/29] rate-lav: Convert to libswresample

The libavresample has been deprecated.  Convert to the new API for
libswresample.

The phase shift and cutoff seem to be either redundant or not-working
properly, so those are dropped.

Signed-off-by: Takashi Iwai <tiwai@suse.de>
Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 configure.ac            |  2 +-
 doc/lavrate.txt         |  4 +--
 rate-lav/rate_lavrate.c | 70 ++++++++++++++++-------------------------
 3 files changed, 30 insertions(+), 46 deletions(-)

diff --git a/configure.ac b/configure.ac
index d5fe529..860daa9 100644
--- a/configure.ac
+++ b/configure.ac
@@ -93,7 +93,7 @@ AC_ARG_ENABLE([libav],
       AS_HELP_STRING([--disable-libav], [Do not build plugins depending on libav/ffmpeg (a52,lavrate...)]))
 
 if test "x$enable_libav" != "xno"; then
-  PKG_CHECK_MODULES(LIBAV, [libavcodec libavutil libavresample], [HAVE_LIBAV=yes], [HAVE_LIBAV=no])
+  PKG_CHECK_MODULES(LIBAV, [libavcodec libavutil libswresample], [HAVE_LIBAV=yes], [HAVE_LIBAV=no])
 fi
 
 if test "x$HAVE_LIBAV" = "xno"; then
diff --git a/doc/lavrate.txt b/doc/lavrate.txt
index 6575183..fa6bbb0 100644
--- a/doc/lavrate.txt
+++ b/doc/lavrate.txt
@@ -2,7 +2,7 @@ Rate Converter Plugin Using libavresample
 =========================================0
 
 The plugin in rate-lavr subdirectory is an external rate converter using
-libavresample library. You can use this rate converter plugin by defining a
+libswresample library. You can use this rate converter plugin by defining a
 rate PCM with "converter" parameter, such as:
 
 	pcm.my_rate {
@@ -16,7 +16,7 @@ The plug plugin has also a similar field, "rate_converter".
 Or, more easily, define a global variable "defaults.pcm.rate_converter",
 which is used as the default converter type by plug and rate plugins:
 
-	defaults.pcm.rate_converter "lavcrate"
+	defaults.pcm.rate_converter "lavrate"
 
 Write the above in your ~/.asoundrc or /etc/asound.conf.
 
diff --git a/rate-lav/rate_lavrate.c b/rate-lav/rate_lavrate.c
index 2b992c5..e9c6740 100644
--- a/rate-lav/rate_lavrate.c
+++ b/rate-lav/rate_lavrate.c
@@ -1,5 +1,5 @@
 /*
- * Rate converter plugin using libavresample
+ * Rate converter plugin using libswresample
  * Copyright (c) 2014 by Anton Khirnov
  *
  * This library is free software; you can redistribute it and/or
@@ -17,7 +17,7 @@
 #include <alsa/asoundlib.h>
 #include <alsa/pcm_rate.h>
 
-#include <libavresample/avresample.h>
+#include <libswresample/swresample.h>
 #include <libavutil/channel_layout.h>
 #include <libavutil/opt.h>
 #include <libavutil/mathematics.h>
@@ -25,11 +25,9 @@
 
 
 static unsigned int filter_size = 16;
-static unsigned int phase_shift = 10; /* auto-adjusts */
-static double cutoff = 0; /* auto-adjusts */
 
 struct rate_src {
-	AVAudioResampleContext *avr;
+	SwrContext *avr;
 
 	unsigned int in_rate;
 	unsigned int out_rate;
@@ -51,51 +49,38 @@ static snd_pcm_uframes_t output_frames(void *obj ATTRIBUTE_UNUSED,
 static void pcm_src_free(void *obj)
 {
 	struct rate_src *rate = obj;
-	avresample_free(&rate->avr);
+	swr_free(&rate->avr);
 }
 
 static int pcm_src_init(void *obj, snd_pcm_rate_info_t *info)
 {
 	struct rate_src *rate = obj;
-	int i, ir, or;
 
 	if (!rate->avr || rate->channels != info->channels) {
 		int ret;
 
 		pcm_src_free(rate);
 		rate->channels = info->channels;
-		ir = rate->in_rate = info->in.rate;
-		or = rate->out_rate = info->out.rate;
-		i = av_gcd(or, ir);
-		if (or > ir) {
-			phase_shift = or/i;
-		} else {
-			phase_shift = ir/i;
-		}
-		if (cutoff <= 0.0) {
-			cutoff = 1.0 - 1.0/filter_size;
-			if (cutoff < 0.80)
-				cutoff = 0.80;
-		}
+		rate->in_rate = info->in.rate;
+		rate->out_rate = info->out.rate;
 
-		rate->avr = avresample_alloc_context();
+		rate->avr = swr_alloc();
 		if (!rate->avr)
 			return -ENOMEM;
 
-		av_opt_set_int(rate->avr, "in_sample_rate",     info->in.rate,  0);
-		av_opt_set_int(rate->avr, "out_sample_rate",    info->out.rate, 0);
-		av_opt_set_int(rate->avr, "in_sample_format",   AV_SAMPLE_FMT_S16, 0);
-		av_opt_set_int(rate->avr, "out_sample_format",  AV_SAMPLE_FMT_S16, 0);
-		av_opt_set_int(rate->avr, "in_channel_layout",  av_get_default_channel_layout(rate->channels), 0);
-		av_opt_set_int(rate->avr, "out_channel_layout", av_get_default_channel_layout(rate->channels), 0);
+		av_opt_set_channel_layout(rate->avr, "in_channel_layout",
+					  av_get_default_channel_layout(rate->channels), 0);
+		av_opt_set_channel_layout(rate->avr, "out_channel_layout",
+					  av_get_default_channel_layout(rate->channels), 0);
+		av_opt_set_int(rate->avr, "in_sample_rate", rate->in_rate, 0);
+		av_opt_set_int(rate->avr, "out_sample_rate", rate->out_rate, 0);
+		av_opt_set_sample_fmt(rate->avr, "in_sample_fmt", AV_SAMPLE_FMT_S16, 0);
+		av_opt_set_sample_fmt(rate->avr, "out_sample_fmt", AV_SAMPLE_FMT_S16, 0);
 
-		av_opt_set_int(rate->avr, "filter_size",        filter_size, 0);
-		av_opt_set_int(rate->avr, "phase_shift",        phase_shift, 0);
-		av_opt_set_double(rate->avr, "cutoff",          cutoff,      0);
-
-		ret = avresample_open(rate->avr);
+		ret = swr_init(rate->avr);
 		if (ret < 0) {
-			avresample_free(&rate->avr);
+			SNDERR("sw_init() error %d\n", ret);
+			swr_free(&rate->avr);
 			return -EINVAL;
 		}
 	}
@@ -118,8 +103,8 @@ static void pcm_src_reset(void *obj)
 
 	if (rate->avr) {
 #if 0
-		avresample_close(rate->avr);
-		avresample_open(rate->avr);
+		swr_free(rate->avr);
+		swr_init(rate->avr);
 #endif
 	}
 }
@@ -130,14 +115,14 @@ static void pcm_src_convert_s16(void *obj, int16_t *dst,
 				unsigned int src_frames)
 {
 	struct rate_src *rate = obj;
-	int chans = rate->channels;
-	unsigned int total_in = avresample_get_delay(rate->avr) + src_frames;
+	unsigned int total_in = swr_get_delay(rate->avr, rate->in_rate) + src_frames;
 
-	avresample_convert(rate->avr, (uint8_t **)&dst, dst_frames * chans * 2, dst_frames,
-	                   (uint8_t **)&src, src_frames * chans * 2, src_frames);
+	swr_convert(rate->avr, (uint8_t **)&dst, dst_frames,
+		    (const uint8_t **)&src, src_frames);
 
-	avresample_set_compensation(rate->avr,
-                                    total_in - src_frames > filter_size ? 0 : 1, src_frames);
+	swr_set_compensation(rate->avr,
+			     total_in - src_frames > filter_size ? 0 : 1,
+			     src_frames);
 }
 
 static void pcm_src_close(void *obj)
@@ -156,7 +141,7 @@ static int get_supported_rates(void *obj ATTRIBUTE_UNUSED,
 
 static void dump(void *obj ATTRIBUTE_UNUSED, snd_output_t *out)
 {
-	snd_output_printf(out, "Converter: libavr\n");
+	snd_output_printf(out, "Converter: libswresample\n");
 }
 #endif
 
@@ -177,7 +162,6 @@ static snd_pcm_rate_ops_t pcm_src_ops = {
 };
 
 int pcm_src_open(unsigned int version, void **objp, snd_pcm_rate_ops_t *ops)
-
 {
 	struct rate_src *rate;
 
-- 
2.31.1


From 7564ceb939681fa64b5df196c35f31065f58a5e9 Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Thu, 17 Jun 2021 11:03:04 +0200
Subject: [PATCH 24/29] rate-lav: Support multiple formats

Now that ALSA rate plugin core allows each rate plugin dealing with
multiple formats, this patch extends the rate-lav plugin to accept
more formats, namely, U8, S16 and S32.  The code has been carefully
modified so that it should still be compilable with old alsa-lib.

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 rate-lav/rate_lavrate.c | 115 ++++++++++++++++++++++++++++++++++------
 1 file changed, 99 insertions(+), 16 deletions(-)

diff --git a/rate-lav/rate_lavrate.c b/rate-lav/rate_lavrate.c
index e9c6740..2ab1d88 100644
--- a/rate-lav/rate_lavrate.c
+++ b/rate-lav/rate_lavrate.c
@@ -32,6 +32,8 @@ struct rate_src {
 	unsigned int in_rate;
 	unsigned int out_rate;
 	unsigned int channels;
+
+	unsigned int version;
 };
 
 static snd_pcm_uframes_t input_frames(void *obj ATTRIBUTE_UNUSED,
@@ -52,9 +54,34 @@ static void pcm_src_free(void *obj)
 	swr_free(&rate->avr);
 }
 
+static int to_av_format(snd_pcm_format_t f)
+{
+	switch (f) {
+	case SND_PCM_FORMAT_FLOAT:
+		return AV_SAMPLE_FMT_FLT;
+	case SND_PCM_FORMAT_U8:
+		return AV_SAMPLE_FMT_U8;
+	case SND_PCM_FORMAT_S16:
+		return AV_SAMPLE_FMT_S16;
+	case SND_PCM_FORMAT_S32:
+	default:
+		return AV_SAMPLE_FMT_S32;
+	}
+}
+
+static int support_multi_format(struct rate_src *rate)
+{
+#if SND_PCM_RATE_PLUGIN_VERSION >= 0x010003
+	return rate->version >= 0x010003;
+#else
+	return 0;
+#endif
+}
+
 static int pcm_src_init(void *obj, snd_pcm_rate_info_t *info)
 {
 	struct rate_src *rate = obj;
+	int fmt;
 
 	if (!rate->avr || rate->channels != info->channels) {
 		int ret;
@@ -74,8 +101,12 @@ static int pcm_src_init(void *obj, snd_pcm_rate_info_t *info)
 					  av_get_default_channel_layout(rate->channels), 0);
 		av_opt_set_int(rate->avr, "in_sample_rate", rate->in_rate, 0);
 		av_opt_set_int(rate->avr, "out_sample_rate", rate->out_rate, 0);
-		av_opt_set_sample_fmt(rate->avr, "in_sample_fmt", AV_SAMPLE_FMT_S16, 0);
-		av_opt_set_sample_fmt(rate->avr, "out_sample_fmt", AV_SAMPLE_FMT_S16, 0);
+		fmt = support_multi_format(rate) ? info->in.format : SND_PCM_FORMAT_S16;
+		av_opt_set_sample_fmt(rate->avr, "in_sample_fmt",
+				      to_av_format(fmt), 0);
+		fmt = support_multi_format(rate) ? info->out.format : SND_PCM_FORMAT_S16;
+		av_opt_set_sample_fmt(rate->avr, "out_sample_fmt",
+				      to_av_format(fmt), 0);
 
 		ret = swr_init(rate->avr);
 		if (ret < 0) {
@@ -109,12 +140,10 @@ static void pcm_src_reset(void *obj)
 	}
 }
 
-static void pcm_src_convert_s16(void *obj, int16_t *dst,
-				unsigned int dst_frames,
-				const int16_t *src,
-				unsigned int src_frames)
+static void do_convert(struct rate_src *rate,
+		       void *dst, unsigned int dst_frames,
+		       const void *src, unsigned int src_frames)
 {
-	struct rate_src *rate = obj;
 	unsigned int total_in = swr_get_delay(rate->avr, rate->in_rate) + src_frames;
 
 	swr_convert(rate->avr, (uint8_t **)&dst, dst_frames,
@@ -125,6 +154,38 @@ static void pcm_src_convert_s16(void *obj, int16_t *dst,
 			     src_frames);
 }
 
+#if SND_PCM_RATE_PLUGIN_VERSION >= 0x010003
+static inline void *get_addr(const snd_pcm_channel_area_t *area, snd_pcm_uframes_t offset)
+{
+	return (char *)area->addr + (area->first + area->step * offset) / 8;
+}
+
+static void pcm_src_convert(void *obj,
+			    const snd_pcm_channel_area_t *dst_areas,
+			    snd_pcm_uframes_t dst_offset,
+			    unsigned int dst_frames,
+			    const snd_pcm_channel_area_t *src_areas,
+			    snd_pcm_uframes_t src_offset,
+			    unsigned int src_frames)
+{
+	struct rate_src *rate = obj;
+	const void *src = get_addr(src_areas, src_offset);
+	void *dst = get_addr(dst_areas, dst_offset);
+
+	do_convert(rate, dst, dst_frames, src, src_frames);
+}
+#endif
+
+static void pcm_src_convert_s16(void *obj, int16_t *dst,
+				unsigned int dst_frames,
+				const int16_t *src,
+				unsigned int src_frames)
+{
+	struct rate_src *rate = obj;
+
+	do_convert(rate, dst, dst_frames, src, src_frames);
+}
+
 static void pcm_src_close(void *obj)
 {
 	pcm_src_free(obj);
@@ -145,12 +206,29 @@ static void dump(void *obj ATTRIBUTE_UNUSED, snd_output_t *out)
 }
 #endif
 
+#if SND_PCM_RATE_PLUGIN_VERSION >= 0x010003
+static int get_supported_formats(void *obj, uint64_t *in_formats,
+				 uint64_t *out_formats,
+				 unsigned int *flags)
+{
+	*in_formats = *out_formats =
+		(1ULL << SND_PCM_FORMAT_U8) |
+		(1ULL << SND_PCM_FORMAT_S16) |
+		(1ULL << SND_PCM_FORMAT_S32);
+	*flags = SND_PCM_RATE_FLAG_INTERLEAVED;
+	return 0;
+}
+#endif
+
 static snd_pcm_rate_ops_t pcm_src_ops = {
 	.close = pcm_src_close,
 	.init = pcm_src_init,
 	.free = pcm_src_free,
 	.reset = pcm_src_reset,
 	.adjust_pitch = pcm_src_adjust_pitch,
+#if SND_PCM_RATE_PLUGIN_VERSION >= 0x010003
+	.convert = pcm_src_convert,
+#endif
 	.convert_s16 = pcm_src_convert_s16,
 	.input_frames = input_frames,
 	.output_frames = output_frames,
@@ -159,30 +237,35 @@ static snd_pcm_rate_ops_t pcm_src_ops = {
 	.get_supported_rates = get_supported_rates,
 	.dump = dump,
 #endif
+#if SND_PCM_RATE_PLUGIN_VERSION >= 0x010003
+	.get_supported_formats = get_supported_formats,
+#endif
 };
 
 int pcm_src_open(unsigned int version, void **objp, snd_pcm_rate_ops_t *ops)
 {
 	struct rate_src *rate;
 
-#if SND_PCM_RATE_PLUGIN_VERSION < 0x010002
-	if (version != SND_PCM_RATE_PLUGIN_VERSION) {
-		fprintf(stderr, "Invalid rate plugin version %x\n", version);
-		return -EINVAL;
-	}
-#endif
 	rate = calloc(1, sizeof(*rate));
 	if (!rate)
 		return -ENOMEM;
 
 	*objp = rate;
 	rate->avr = NULL;
+	rate->version = version;
 #if SND_PCM_RATE_PLUGIN_VERSION >= 0x010002
-	if (version == 0x010001)
+	if (version == 0x010001) {
 		memcpy(ops, &pcm_src_ops, sizeof(snd_pcm_rate_old_ops_t));
-	else
+		return 0;
+	}
+#endif
+#if SND_PCM_RATE_PLUGIN_VERSION >= 0x010003
+	if (version == 0x010002) {
+		memcpy(ops, &pcm_src_ops, sizeof(snd_pcm_rate_v2_ops_t));
+		return 0;
+	}
 #endif
-		*ops = pcm_src_ops;
+	*ops = pcm_src_ops;
 	return 0;
 }
 
-- 
2.31.1


From fcdff93e1af1c05824431e395b5fa91b99d4ee23 Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Thu, 17 Jun 2021 11:03:04 +0200
Subject: [PATCH 25/29] samplerate: Support multiple formats

Now that ALSA rate plugin core allows each rate plugin dealing with
multiple formats, this patch extends the libsamplerate plugin to
accept more formats, namely, S16 and S32.  The code has been carefully
modified so that it should still be compilable with old alsa-lib.

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 rate/rate_samplerate.c | 99 +++++++++++++++++++++++++++++++++++-------
 1 file changed, 84 insertions(+), 15 deletions(-)

diff --git a/rate/rate_samplerate.c b/rate/rate_samplerate.c
index 100d6f2..af0bf98 100644
--- a/rate/rate_samplerate.c
+++ b/rate/rate_samplerate.c
@@ -40,9 +40,12 @@
 #include <alsa/pcm_rate.h>
 
 struct rate_src {
+	unsigned int version;
 	double ratio;
 	int converter;
 	unsigned int channels;
+	int in_int;
+	int out_int;
 	float *src_buf;
 	float *dst_buf;
 	SRC_STATE *state;
@@ -109,6 +112,13 @@ static int pcm_src_init(void *obj, snd_pcm_rate_info_t *info)
 	rate->data.src_ratio = rate->ratio;
 	rate->data.end_of_input = 0;
 
+#if SND_PCM_RATE_PLUGIN_VERSION >= 0x010003
+	if (rate->version >= 0x010003) {
+		rate->in_int = info->in.format == SND_PCM_FORMAT_S32;
+		rate->out_int = info->out.format == SND_PCM_FORMAT_S32;
+	}
+#endif
+
 	return 0;
 }
 
@@ -128,24 +138,61 @@ static void pcm_src_reset(void *obj)
 	src_reset(rate->state);
 }
 
-static void pcm_src_convert_s16(void *obj, int16_t *dst, unsigned int dst_frames,
-				const int16_t *src, unsigned int src_frames)
+static void do_convert(struct rate_src *rate,
+		       void *dst, unsigned int dst_frames,
+		       const void *src, unsigned int src_frames)
 {
-	struct rate_src *rate = obj;
 	unsigned int ofs;
 
 	rate->data.input_frames = src_frames;
 	rate->data.output_frames = dst_frames;
 	rate->data.end_of_input = 0;
 	
-	src_short_to_float_array(src, rate->src_buf, src_frames * rate->channels);
+	if (rate->in_int)
+		src_int_to_float_array(src, rate->src_buf, src_frames * rate->channels);
+	else
+		src_short_to_float_array(src, rate->src_buf, src_frames * rate->channels);
 	src_process(rate->state, &rate->data);
 	if (rate->data.output_frames_gen < dst_frames)
 		ofs = dst_frames - rate->data.output_frames_gen;
 	else
 		ofs = 0;
-	src_float_to_short_array(rate->dst_buf, dst + ofs * rate->channels,
-				 rate->data.output_frames_gen * rate->channels);
+	if (rate->out_int)
+		src_float_to_int_array(rate->dst_buf, dst + ofs * rate->channels * 4,
+				       rate->data.output_frames_gen * rate->channels);
+	else
+		src_float_to_short_array(rate->dst_buf, dst + ofs * rate->channels * 2,
+					 rate->data.output_frames_gen * rate->channels);
+}
+
+#if SND_PCM_RATE_PLUGIN_VERSION >= 0x010003
+static inline void *get_addr(const snd_pcm_channel_area_t *area, snd_pcm_uframes_t offset)
+{
+	return (char *)area->addr + (area->first + area->step * offset) / 8;
+}
+
+static void pcm_src_convert(void *obj,
+			    const snd_pcm_channel_area_t *dst_areas,
+			    snd_pcm_uframes_t dst_offset,
+			    unsigned int dst_frames,
+			    const snd_pcm_channel_area_t *src_areas,
+			    snd_pcm_uframes_t src_offset,
+			    unsigned int src_frames)
+{
+	struct rate_src *rate = obj;
+	const void *src = get_addr(src_areas, src_offset);
+	void *dst = get_addr(dst_areas, dst_offset);
+
+	do_convert(rate, dst, dst_frames, src, src_frames);
+}
+#endif
+
+static void pcm_src_convert_s16(void *obj, int16_t *dst, unsigned int dst_frames,
+				const int16_t *src, unsigned int src_frames)
+{
+	struct rate_src *rate = obj;
+
+	do_convert(rate, dst, dst_frames, src, src_frames);
 }
 
 static void pcm_src_close(void *obj)
@@ -167,12 +214,28 @@ static void dump(void *obj ATTRIBUTE_UNUSED, snd_output_t *out)
 }
 #endif
 
+#if SND_PCM_RATE_PLUGIN_VERSION >= 0x010003
+static int get_supported_formats(void *obj, uint64_t *in_formats,
+				 uint64_t *out_formats,
+				 unsigned int *flags)
+{
+	*in_formats = *out_formats =
+		(1ULL << SND_PCM_FORMAT_S16) |
+		(1ULL << SND_PCM_FORMAT_S32);
+	*flags = SND_PCM_RATE_FLAG_INTERLEAVED;
+	return 0;
+}
+#endif
+
 static snd_pcm_rate_ops_t pcm_src_ops = {
 	.close = pcm_src_close,
 	.init = pcm_src_init,
 	.free = pcm_src_free,
 	.reset = pcm_src_reset,
 	.adjust_pitch = pcm_src_adjust_pitch,
+#if SND_PCM_RATE_PLUGIN_VERSION >= 0x010003
+	.convert = pcm_src_convert,
+#endif
 	.convert_s16 = pcm_src_convert_s16,
 	.input_frames = input_frames,
 	.output_frames = output_frames,
@@ -181,6 +244,9 @@ static snd_pcm_rate_ops_t pcm_src_ops = {
 	.get_supported_rates = get_supported_rates,
 	.dump = dump,
 #endif
+#if SND_PCM_RATE_PLUGIN_VERSION >= 0x010003
+	.get_supported_formats = get_supported_formats,
+#endif
 };
 
 static int pcm_src_open(unsigned int version, void **objp,
@@ -188,24 +254,27 @@ static int pcm_src_open(unsigned int version, void **objp,
 {
 	struct rate_src *rate;
 
-#if SND_PCM_RATE_PLUGIN_VERSION < 0x010002
-	if (version != SND_PCM_RATE_PLUGIN_VERSION) {
-		fprintf(stderr, "Invalid rate plugin version %x\n", version);
-		return -EINVAL;
-	}
-#endif
 	rate = calloc(1, sizeof(*rate));
 	if (! rate)
 		return -ENOMEM;
+
+	rate->version = version;
 	rate->converter = type;
 
 	*objp = rate;
 #if SND_PCM_RATE_PLUGIN_VERSION >= 0x010002
-	if (version == 0x010001)
+	if (version == 0x010001) {
 		memcpy(ops, &pcm_src_ops, sizeof(snd_pcm_rate_old_ops_t));
-	else
+		return 0;
+	}
+#endif
+#if SND_PCM_RATE_PLUGIN_VERSION >= 0x010003
+	if (version == 0x010002) {
+		memcpy(ops, &pcm_src_ops, sizeof(snd_pcm_rate_v2_ops_t));
+		return 0;
+	}
 #endif
-		*ops = pcm_src_ops;
+	*ops = pcm_src_ops;
 	return 0;
 }
 
-- 
2.31.1


From 2687de213673338a631084fb1e04695b15751d12 Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Fri, 18 Jun 2021 08:58:29 +0200
Subject: [PATCH 26/29] a52: fix a52_pointer return value

BugLink: https://github.com/alsa-project/alsa-plugins/issues/28
Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 46 ++++++++++++++++++++++------------------------
 1 file changed, 22 insertions(+), 24 deletions(-)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index d28c8c3..5409b0a 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -96,11 +96,12 @@ struct a52_ctx {
 	unsigned char *outbuf1;
 	unsigned char *outbuf2;
 	int outbuf_size;
-	snd_pcm_uframes_t transfer;
 	int remain;
 	int filled;
 	unsigned int slave_period_size;
 	unsigned int slave_buffer_size;
+	snd_pcm_uframes_t pointer;
+	snd_pcm_uframes_t boundary;
 	snd_pcm_hw_params_t *hw_params;
 #ifdef USE_AVCODEC_PACKET_ALLOC
 	AVPacket *pkt;
@@ -202,9 +203,6 @@ static int write_out_pending(snd_pcm_ioplug_t *io, struct a52_ctx *rec)
 	snd_pcm_sframes_t ret;
 	unsigned int ofs;
 
-	if (! rec->remain)
-		return 0;
-
 	while (rec->remain) {
 		ofs = (rec->avctx->frame_size - rec->remain) * 4;
 		ret = snd_pcm_writei(rec->slave, rec->outbuf + ofs, rec->remain);
@@ -314,9 +312,12 @@ static int fill_data(snd_pcm_ioplug_t *io,
 
 	/* If there are still frames left in outbuf, we can't
 	 * accept a full a52 frame, because this would overwrite
-	 * the frames in outbuf. */
-	if (rec->remain && len)
+	 * the frames in outbuf. This should not happen! The a52_pointer()
+	 * callback should limit the transferred frames correctly. */
+	if (rec->remain && len) {
+		SNDERR("fill data issue (remain is %i)", rec->remain);
 		len--;
+	}
 
 	if (size > len)
 		size = len;
@@ -410,7 +411,8 @@ static snd_pcm_sframes_t a52_transfer(snd_pcm_ioplug_t *io,
 		offset += (unsigned int)err;
 		size -= (unsigned int)err;
 		result += err;
-		rec->transfer += err;
+		rec->pointer += err;
+		rec->pointer %= rec->boundary;
 	} while (size);
 	return result > 0 ? result : err;
 }
@@ -423,7 +425,7 @@ static snd_pcm_sframes_t a52_transfer(snd_pcm_ioplug_t *io,
 static snd_pcm_sframes_t a52_pointer(snd_pcm_ioplug_t *io)
 {
 	struct a52_ctx *rec = io->private_data;
-	snd_pcm_sframes_t avail;
+	snd_pcm_sframes_t avail, delay;
 	snd_pcm_state_t state;
 
 	state = snd_pcm_state(rec->slave);
@@ -432,31 +434,26 @@ static snd_pcm_sframes_t a52_pointer(snd_pcm_ioplug_t *io)
 	case SND_PCM_STATE_DRAINING:
 		break;
 	case SND_PCM_STATE_XRUN:
-	case SND_PCM_STATE_SUSPENDED:
 		return -EPIPE;
+	case SND_PCM_STATE_SUSPENDED:
+		return -ESTRPIPE;
 	default:
 		return 0;
 	}
 
-	avail = 0;
-
 	/* Write what we have from outbuf. */
 	write_out_pending(io, rec);
 
-	/* If there is anything remaining in outbuf, we can't
-	 * accept any full packets. */
-	if (rec->remain == 0)
-	{
-		/* Round the slave frames to multiples of the packet size. */
-		avail += (snd_pcm_avail_update(rec->slave) / rec->avctx->frame_size) * rec->avctx->frame_size;
-	}
-
+	avail = snd_pcm_avail(rec->slave);
 	if (avail < 0)
-		avail = 0;
-	else if ((snd_pcm_uframes_t)avail >= io->buffer_size)
-		avail = io->buffer_size - 1;
+		return avail;
+
+	/* get buffer delay without additional FIFO information */
+	delay = rec->slave_buffer_size - avail;
+	while (delay < 0)
+		delay += rec->slave_buffer_size;
 
-	return (io->appl_ptr + avail) % io->buffer_size;
+	return (rec->pointer - delay - rec->remain - rec->filled) % io->buffer_size;
 }
 
 /* set up the fixed parameters of slave PCM hw_parmas */
@@ -582,6 +579,7 @@ static int a52_sw_params(snd_pcm_ioplug_t *io, snd_pcm_sw_params_t *params)
 
 	snd_pcm_sw_params_get_avail_min(params, &avail_min);
 	snd_pcm_sw_params_get_start_threshold(params, &start_threshold);
+	snd_pcm_sw_params_get_boundary(params, &rec->boundary);
 
 	len = avail_min;
 	len += (int)rec->slave_buffer_size - (int)io->buffer_size;
@@ -763,7 +761,7 @@ static int a52_prepare(snd_pcm_ioplug_t *io)
 	if (alloc_input_buffer(io))
 		return -ENOMEM;
 
-	rec->transfer = 0;
+	rec->pointer = 0;
 	rec->remain = 0;
 	rec->filled = 0;
 
-- 
2.31.1


From 873d962332b912a0bf78f9deb67275ea2182941b Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Fri, 18 Jun 2021 09:07:55 +0200
Subject: [PATCH 27/29] a52: add support for SND_PCM_IOPLUG_FLAG_BOUNDARY_WA

Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 10 +++++++++-
 1 file changed, 9 insertions(+), 1 deletion(-)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index 5409b0a..28dbd93 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -453,7 +453,12 @@ static snd_pcm_sframes_t a52_pointer(snd_pcm_ioplug_t *io)
 	while (delay < 0)
 		delay += rec->slave_buffer_size;
 
-	return (rec->pointer - delay - rec->remain - rec->filled) % io->buffer_size;
+	avail = rec->pointer - delay - rec->remain - rec->filled;
+#ifdef SND_PCM_IOPLUG_FLAG_BOUNDARY_WA
+	return avail % rec->boundary;
+#else
+	return avail % io->buffer_size;
+#endif
 }
 
 /* set up the fixed parameters of slave PCM hw_parmas */
@@ -1158,6 +1163,9 @@ SND_PCM_PLUGIN_DEFINE_FUNC(a52)
 	rec->io.mmap_rw = 0;
 	rec->io.callback = &a52_ops;
 	rec->io.private_data = rec;
+#ifdef SND_PCM_IOPLUG_FLAG_BOUNDARY_WA
+	rec->io.flags = SND_PCM_IOPLUG_FLAG_BOUNDARY_WA;
+#endif
 #ifdef USE_AVCODEC_FRAME
 	rec->av_format = rec->codec->sample_fmts[0];
 	rec->is_planar = av_sample_fmt_is_planar(rec->av_format);
-- 
2.31.1


From 4219f4b3fded74d7b07a54c3ba8661d7a18c3b6c Mon Sep 17 00:00:00 2001
From: Takashi Iwai <tiwai@suse.de>
Date: Mon, 21 Jun 2021 14:24:50 +0200
Subject: [PATCH 28/29] rate: Simplify with snd_pcm_channel_area_addr()

Use the new common helper instead of the open code.

Signed-off-by: Takashi Iwai <tiwai@suse.de>
---
 rate-lav/rate_lavrate.c | 9 ++-------
 rate/rate_samplerate.c  | 9 ++-------
 2 files changed, 4 insertions(+), 14 deletions(-)

diff --git a/rate-lav/rate_lavrate.c b/rate-lav/rate_lavrate.c
index 2ab1d88..f78eea5 100644
--- a/rate-lav/rate_lavrate.c
+++ b/rate-lav/rate_lavrate.c
@@ -155,11 +155,6 @@ static void do_convert(struct rate_src *rate,
 }
 
 #if SND_PCM_RATE_PLUGIN_VERSION >= 0x010003
-static inline void *get_addr(const snd_pcm_channel_area_t *area, snd_pcm_uframes_t offset)
-{
-	return (char *)area->addr + (area->first + area->step * offset) / 8;
-}
-
 static void pcm_src_convert(void *obj,
 			    const snd_pcm_channel_area_t *dst_areas,
 			    snd_pcm_uframes_t dst_offset,
@@ -169,8 +164,8 @@ static void pcm_src_convert(void *obj,
 			    unsigned int src_frames)
 {
 	struct rate_src *rate = obj;
-	const void *src = get_addr(src_areas, src_offset);
-	void *dst = get_addr(dst_areas, dst_offset);
+	const void *src = snd_pcm_channel_area_addr(src_areas, src_offset);
+	void *dst = snd_pcm_channel_area_addr(dst_areas, dst_offset);
 
 	do_convert(rate, dst, dst_frames, src, src_frames);
 }
diff --git a/rate/rate_samplerate.c b/rate/rate_samplerate.c
index af0bf98..dd0a416 100644
--- a/rate/rate_samplerate.c
+++ b/rate/rate_samplerate.c
@@ -166,11 +166,6 @@ static void do_convert(struct rate_src *rate,
 }
 
 #if SND_PCM_RATE_PLUGIN_VERSION >= 0x010003
-static inline void *get_addr(const snd_pcm_channel_area_t *area, snd_pcm_uframes_t offset)
-{
-	return (char *)area->addr + (area->first + area->step * offset) / 8;
-}
-
 static void pcm_src_convert(void *obj,
 			    const snd_pcm_channel_area_t *dst_areas,
 			    snd_pcm_uframes_t dst_offset,
@@ -180,8 +175,8 @@ static void pcm_src_convert(void *obj,
 			    unsigned int src_frames)
 {
 	struct rate_src *rate = obj;
-	const void *src = get_addr(src_areas, src_offset);
-	void *dst = get_addr(dst_areas, dst_offset);
+	const void *src = snd_pcm_channel_area_addr(src_areas, src_offset);
+	void *dst = snd_pcm_channel_area_addr(dst_areas, dst_offset);
 
 	do_convert(rate, dst, dst_frames, src, src_frames);
 }
-- 
2.31.1


From da157e978d73f1947bb77637c324e19d003366d4 Mon Sep 17 00:00:00 2001
From: Jaroslav Kysela <perex@perex.cz>
Date: Thu, 29 Jul 2021 14:51:55 +0200
Subject: [PATCH 29/29] a52: fix the double free for rec->slave and rec

The function snd_pcm_ioplug_delete() calls the close ops callback already,
thus exit more early in the error path.

Fixes: https://github.com/alsa-project/alsa-plugins/issues/31
Signed-off-by: Jaroslav Kysela <perex@perex.cz>
---
 a52/pcm_a52.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/a52/pcm_a52.c b/a52/pcm_a52.c
index 28dbd93..289a9db 100644
--- a/a52/pcm_a52.c
+++ b/a52/pcm_a52.c
@@ -1179,7 +1179,7 @@ SND_PCM_PLUGIN_DEFINE_FUNC(a52)
 
 	if ((err = a52_set_hw_constraint(rec)) < 0) {
 		snd_pcm_ioplug_delete(&rec->io);
-		goto error;
+		return err;
 	}
 
 	*pcmp = rec->io.pcm;
-- 
2.31.1

